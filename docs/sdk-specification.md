## SDK 规范

### 动机

SDK 的目的在于方便用户使用 IDE 集成开发、和模拟调试。

### 位置

```
    +------------------+
    |   User's Codes   |
    +------------------+
    |       SDK        |    <====   The SDK Located
    +------------------+
    |     Raw APIs     |
    +------------------+
    |      Driver      |
    +==================+
             ||
    +==================+
    |   EMQ X Plugin   |
    +------------------+
```

因此，SDK 的作用在于封装底层的比较晦涩的数据格式和方法，屏蔽底层细节。直接提供优化 API 供用户使用。


### 实现要求

**声明：** stdin, stdout 已用于和 EMQ X 通信，请不要使用。stderr 用于日志输出。

#### 基础项

1. 必须将原始的 `init` `deinit`函数进行封装，方便用户：
   - 配置需要挂载的钩子列表
   - 定义用户自己的初始化和销毁的内容
2. 必须将回调函数的各个松散的数据类型，封装成类或某种结构化类型。
3. 必须要有对应的开发、部署文档说明

#### 高级项

1. 应能方便用户能在 IDE 中进行，集成和开发
2. 应提供集成测试用的模拟代码。
   - 例如，生成模拟的数据，发送至用户的程序，方便直接断点调试


### 部署结构

#### 代码依赖结构

从部署的角度看，代码的依赖关系为：

1. 用户代码：
    * 一定会依赖 SDK
    * 可能会依赖 某个位置的三方/系统库
2. SDK 代码：
    * 只能依赖 erlport
3. 基础通信库
    * 无依赖

#### 部署

从文件存放的位置来看，一个标准的部署结构为：

```
emqx
|
|--- data
|------- extension
|---------- <some-sdk-package-name>
|--------------- <some-classes/scripts-in-sdk>
|---------- <user's classes/scripts>
|
|---------- <another-sdk-package-name>
|--------------- <some-classes/scripts-in-sdk>
|---------- <user's classes/scripts>
```

它表达了：在 `data/extension` 目录下安装了两个 SDK，并且用户都基于 SDK 编写了其回调的代码模块。
